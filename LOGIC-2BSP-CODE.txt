================================================================================
ПОВНИЙ КОД ЛОГІКИ 2БСП
Дата: 17 жовтня 2025
Файл: electron/main.ts
================================================================================

// ============================================================================
// ТИПИ ДАНИХ
// ============================================================================

interface OrderItem {
  type: 'point' | 'subpoint' | 'dash-point' | 'paragraph'
  number?: string  // "1", "7.1", "8.3" тощо
  text: string
  html: string
  index: number    // оригінальний індекс в документі
  children: OrderItem[]
  parent?: OrderItem
  matchedNames?: string[] // ПІБ знайдені в цьому елементі
}

// ============================================================================
// КРОК 1: ЧИТАННЯ ТА ПАРСИНГ WORD-ДОКУМЕНТА
// ============================================================================

async function extractFormattedParagraphsFromWord(wordBuf: ArrayBuffer): Promise<{
  paragraphs: Array<{ text: string, html: string, isBoldAndUnderlined: boolean }>,
  firstLine: string
}> {
  try {
    const result = await mammoth.convertToHtml({ 
      buffer: Buffer.from(wordBuf)
    })
    
    // Розбити HTML на абзаци, зберігаючи HTML форматування
    const htmlParagraphs = result.value.split(/<\/?p[^>]*>/i).filter(p => p.trim().length > 0)
    
    // === ДІАГНОСТИКА: Вивід перших абзаців HTML ===
    console.log('[extractFormatted] === Перші 5 абзаців HTML ===')
    for (let i = 0; i < Math.min(5, htmlParagraphs.length); i++) {
      console.log(`[extractFormatted] Абзац ${i}: ${htmlParagraphs[i].substring(0, 200)}${htmlParagraphs[i].length > 200 ? '...' : ''}`)
    }
    console.log('[extractFormatted] === Кінець діагностики HTML ===')
    
    const paragraphs = htmlParagraphs.map((htmlPara, index) => {
      const text = htmlPara.replace(/<[^>]+>/g, '').trim()
      const html = htmlPara.trim()
      
      // === ПОКРАЩЕНА ПЕРЕВІРКА ФОРМАТУВАННЯ ===
      // ШтрихПункт = тільки ПІДКРЕСЛЕНИЙ (БЕЗ жирного)
      
      // Варіант 1: Перевірка через теги
      const hasBoldTag = /<(strong|b)(\s|>|\/)/i.test(html)
      const hasUnderlineTag = /<u(\s|>|\/)/i.test(html)
      
      // Варіант 2: Перевірка через inline стилі (для mammoth)
      const hasBoldStyle = /font-weight\s*:\s*bold/i.test(html)
      const hasUnderlineStyle = /text-decoration\s*:\s*underline/i.test(html)
      
      // Комбінована перевірка
      const hasBold = hasBoldTag || hasBoldStyle
      const hasUnderline = hasUnderlineTag || hasUnderlineStyle
      
      // ШтрихПункт = підкреслений БЕЗ жирного
      const isBoldAndUnderlined = hasUnderline && !hasBold
      
      // === КРИТИЧНО: ДІАГНОСТИЧНЕ ЛОГУВАННЯ ===
      if (isBoldAndUnderlined) {
        console.log(`[extractFormatted] ✅ Знайдено ШтрихПункт (підкреслений БЕЗ жирного) на позиції ${index}:`)
        console.log(`[extractFormatted]    Текст: "${text.substring(0, 60)}..."`)
        console.log(`[extractFormatted]    HTML: ${html.substring(0, 150)}...`)
        console.log(`[extractFormatted]    Bold: ${hasBold} (tag: ${hasBoldTag}, style: ${hasBoldStyle})`)
        console.log(`[extractFormatted]    Underline: ${hasUnderline} (tag: ${hasUnderlineTag}, style: ${hasUnderlineStyle})`)
      } else if (text.length > 0 && text.length < 100 && (hasBold || hasUnderline)) {
        // Логування потенційних ШтрихПунктів, які майже підходять
        console.log(`[extractFormatted] ⚠️  Потенційний ШтрихПункт (неправильне форматування) на позиції ${index}:`)
        console.log(`[extractFormatted]    Текст: "${text.substring(0, 60)}..."`)
        console.log(`[extractFormatted]    HTML: ${html.substring(0, 150)}...`)
        console.log(`[extractFormatted]    Bold: ${hasBold}, Underline: ${hasUnderline}`)
        console.log(`[extractFormatted]    ❌ Очікується: Underline=true і Bold=false`)
      }
      
      return {
        text,
        html,
        isBoldAndUnderlined
      }
    }).filter(p => p.text.length > 0)
    
    // Перша строка (перший абзац)
    const firstLine = paragraphs.length > 0 ? paragraphs[0].text : ''
    
    console.log(`[extractFormatted] Загалом знайдено ШтрихПунктів: ${paragraphs.filter(p => p.isBoldAndUnderlined).length}`)
    
    return { paragraphs, firstLine }
  } catch (err) {
    throw new Error(`Помилка читання Word: ${err instanceof Error ? err.message : String(err)}`)
  }
}

// ============================================================================
// КРОК 2: РОЗБІР СТРУКТУРИ НАКАЗУ
// ============================================================================

function parseOrderStructure(paragraphs: Array<{ text: string, html: string, isBoldAndUnderlined: boolean }>): OrderItem[] {
  const structure: OrderItem[] = []
  let currentPoint: OrderItem | null = null
  let currentSubpoint: OrderItem | null = null
  let currentDashPoint: OrderItem | null = null
  
  for (let i = 0; i < paragraphs.length; i++) {
    const para = paragraphs[i]
    const text = para.text.trim()
    const html = para.html.trim()
    const isBoldAndUnderlined = para.isBoldAndUnderlined
    
    // Розпізнавання основних пунктів (1, 2, 3, ... або 1., 2., 3., ...)
    const pointMatch = text.match(/^(\d+)\.?\s+(.+)/) && !text.match(/^\d+\.\d+/)
    if (pointMatch) {
      const matches = text.match(/^(\d+)\.?\s+(.+)/)
      const pointNumber = matches![1]
      const pointText = matches![2]
      
      console.log(`[parseOrderStructure] Знайдено пункт ${pointNumber}: "${pointText.substring(0, 50)}..."`)
      
      currentPoint = {
        type: 'point',
        number: pointNumber,
        text: text,
        html: html,
        index: i,
        children: []
      }
      structure.push(currentPoint)
      currentSubpoint = null
      currentDashPoint = null
      continue
    }
    
    // Розпізнавання підпунктів (7.1, 8.3, ... або 7.1., 8.3., ...)
    const subpointMatch = text.match(/^(\d+\.\d+)\.?\s+(.+)/)
    if (subpointMatch) {
      const subpointNumber = subpointMatch[1]
      const subpointText = subpointMatch[2]
      
      console.log(`[parseOrderStructure] Знайдено підпункт ${subpointNumber}: "${subpointText.substring(0, 50)}..."`)
      
      currentSubpoint = {
        type: 'subpoint',
        number: subpointNumber,
        text: text,
        html: html,
        index: i,
        children: [],
        parent: currentPoint || undefined
      }
      
      if (currentPoint) {
        currentPoint.children.push(currentSubpoint)
      } else {
        structure.push(currentSubpoint)
      }
      currentDashPoint = null
      continue
    }
    
    // Розпізнавання ШтрихПункту (тільки підкреслений, без числової нумерації)
    if (isBoldAndUnderlined) {
      // === ДОДАТКОВА ВАЛІДАЦІЯ ===
      
      // Перевірка 1: Не є пунктом з номером
      const isNumberedPoint = /^\d+\.?\s/.test(text)
      const isNumberedSubpoint = /^\d+\.\d+\.?\s/.test(text)
      
      if (isNumberedPoint || isNumberedSubpoint) {
        console.log(`[parseOrderStructure] ⚠️  Пропущено: текст "${text.substring(0, 40)}..." має форматування ШтрихПункту, але це нумерований пункт`)
        continue
      }
      
      // Перевірка 2: Не занадто довгий (ШтрихПункти зазвичай короткі)
      if (text.length > 200) {
        console.log(`[parseOrderStructure] ⚠️  Пропущено: текст "${text.substring(0, 40)}..." надто довгий для ШтрихПункту (${text.length} символів)`)
      } else {
        console.log(`[parseOrderStructure] ✅ Знайдено ШтрихПункт на позиції ${i}: "${text.substring(0, 50)}..."`)
        
        const dashpoint: OrderItem = {
          type: 'dash-point',
          text: text,
          html: html,
          index: i,
          children: [],
          parent: currentSubpoint || currentPoint || undefined
        }
        
        if (currentSubpoint) {
          currentSubpoint.children.push(dashpoint)
          console.log(`[parseOrderStructure]    → Додано як дочірній елемент підпункту ${currentSubpoint.number}`)
        } else if (currentPoint) {
          currentPoint.children.push(dashpoint)
          console.log(`[parseOrderStructure]    → Додано як дочірній елемент пункту ${currentPoint.number}`)
        } else {
          structure.push(dashpoint)
          console.log(`[parseOrderStructure]    → УВАГА: ШтрихПункт не має батька, додано до кореня`)
        }
        
        currentDashPoint = dashpoint
        continue
      }
    }
    
    // Звичайні абзаци
    const paragraph: OrderItem = {
      type: 'paragraph',
      text: text,
      html: html,
      index: i,
      children: [],
      parent: currentDashPoint || currentSubpoint || currentPoint || undefined
    }
    
    if (currentDashPoint) {
      currentDashPoint.children.push(paragraph)
    } else if (currentSubpoint) {
      currentSubpoint.children.push(paragraph)
    } else if (currentPoint) {
      currentPoint.children.push(paragraph)
    } else {
      structure.push(paragraph)
    }
  }
  
  // === ДІАГНОСТИЧНИЙ ВИВІД СТРУКТУРИ ===
  console.log('[parseOrderStructure] === СТРУКТУРА ДОКУМЕНТА ===')
  function printStructure(items: OrderItem[], depth = 0) {
    for (const item of items) {
      const indent = '  '.repeat(depth)
      const typeLabel = item.type === 'dash-point' ? '⭐ dash-point' : item.type
      console.log(`${indent}${typeLabel}${item.number ? ` ${item.number}` : ''}: "${item.text.substring(0, 40)}..." (index: ${item.index})`)
      if (item.children.length > 0) {
        printStructure(item.children, depth + 1)
      }
    }
  }
  printStructure(structure)
  console.log('[parseOrderStructure] === КІНЕЦЬ СТРУКТУРИ ===')
  
  return structure
}

// ============================================================================
// КРОК 3: ПОШУК ЗБІГІВ ЗА КЛЮЧОВИМ СЛОВОМ
// ============================================================================

function findInOrderStructure(structure: OrderItem[], keyword: string): OrderItem[] {
  const results: OrderItem[] = []
  const addedIndices = new Set<number>()
  const normalizedKeyword = keyword.toLowerCase()
  
  const norm = (text: string) => text.toLowerCase()
  
  // === СТАТИСТИКА ДЛЯ ДІАГНОСТИКИ ===
  let foundParagraphs = 0
  let foundPoints = 0
  let foundSubpoints = 0
  let foundDashPoints = 0
  
  function addWithHierarchy(item: OrderItem): void {
    // Функція для додавання елемента разом з усією його ієрархією батьків
    const hierarchyChain: OrderItem[] = []
    
    // Збираємо всю ієрархію від елемента до кореня
    let current: OrderItem | undefined = item
    while (current) {
      hierarchyChain.unshift(current)
      current = current.parent
    }
    
    // === ЛОГУВАННЯ ІЄРАРХІЇ ===
    console.log(`[findInOrderStructure] Додавання ієрархії для "${item.text.substring(0, 40)}...":`)
    for (const h of hierarchyChain) {
      console.log(`[findInOrderStructure]   ${h.type}${h.number ? ` ${h.number}` : ''}: "${h.text.substring(0, 40)}..."`)
    }
    
    // Додаємо всі елементи ієрархії, уникаючи дублів
    for (const hierarchyItem of hierarchyChain) {
      if (!addedIndices.has(hierarchyItem.index)) {
        results.push(hierarchyItem)
        addedIndices.add(hierarchyItem.index)
        
        // Підрахунок статистики
        if (hierarchyItem.type === 'dash-point') {
          foundDashPoints++
          console.log(`[findInOrderStructure]   ✅ Додано ШтрихПункт: "${hierarchyItem.text.substring(0, 40)}..."`)
        } else if (hierarchyItem.type === 'point') {
          foundPoints++
        } else if (hierarchyItem.type === 'subpoint') {
          foundSubpoints++
        } else if (hierarchyItem.type === 'paragraph') {
          foundParagraphs++
        }
      }
    }
  }
  
  function searchRecursive(items: OrderItem[]): void {
    for (const item of items) {
      const normalizedText = norm(item.text)
      
      if (normalizedText.includes(normalizedKeyword)) {
        console.log(`[findInOrderStructure] 🎯 Знайдено збіг в ${item.type}${item.number ? ` ${item.number}` : ''}: "${item.text.substring(0, 60)}..."`)
        
        if (item.parent) {
          console.log(`[findInOrderStructure]    Батько: ${item.parent.type}${item.parent.number ? ` ${item.parent.number}` : ''}: "${item.parent.text.substring(0, 40)}..."`)
        }
        
        addWithHierarchy(item)
      }
      
      // Рекурсивний пошук в дочірніх елементах
      if (item.children.length > 0) {
        searchRecursive(item.children)
      }
    }
  }
  
  searchRecursive(structure)
  
  // === ФІНАЛЬНА СТАТИСТИКА ===
  console.log(`[findInOrderStructure] === СТАТИСТИКА ПОШУКУ ===`)
  console.log(`[findInOrderStructure] Всього елементів в результаті: ${results.length}`)
  console.log(`[findInOrderStructure]   - Пунктів: ${foundPoints}`)
  console.log(`[findInOrderStructure]   - Підпунктів: ${foundSubpoints}`)
  console.log(`[findInOrderStructure]   - ШтрихПунктів: ${foundDashPoints} ⭐`)
  console.log(`[findInOrderStructure]   - Абзаців: ${foundParagraphs}`)
  
  // Сортуємо результати за оригінальним порядком в документі
  return results.sort((a, b) => a.index - b.index)
}

// ============================================================================
// КРОК 4: СТВОРЕННЯ РЕЗУЛЬТУЮЧОГО ДОКУМЕНТА
// ============================================================================

async function createStructuredResultDocument(
  matchedItems: OrderItem[], 
  outputPath: string, 
  firstLine?: string
): Promise<void> {
  const children = []
  
  // Додати першу строку наказу, якщо є
  if (firstLine) {
    children.push(new Paragraph({ 
      children: [new TextRun({
        text: firstLine,
        font: { name: 'Calibri' },
        size: 28 // 14pt
      })],
      alignment: 'both',
      indent: {
        firstLine: 720
      },
      spacing: { after: 200 }
    }))
  }
  
  // Функція для конвертації OrderItem в Paragraph
  function createParagraphFromItem(item: OrderItem): Paragraph {
    let displayText = item.text
    
    if (item.number && (item.type === 'point' || item.type === 'subpoint')) {
      const cleanText = item.text.replace(/^\d+(\.\d+)?\.?\s*/, '')
      displayText = `${item.number}. ${cleanText}`
    }
    
    // Визначити форматування залежно від типу
    // ШтрихПункт = тільки підкреслений (БЕЗ жирного)
    const isBold = item.type === 'point' || item.type === 'subpoint'
    const isUnderline = item.type === 'dash-point'
    
    const textRun = new TextRun({
      text: displayText,
      font: "Calibri",
      size: 28,
      bold: isBold,
      underline: isUnderline ? { type: 'single' } : undefined
    })
    
    return new Paragraph({
      children: [textRun],
      alignment: 'both',
      indent: {
        firstLine: 720
      }
    })
  }
  
  // Додати знайдені елементи
  if (matchedItems.length > 0) {
    for (let i = 0; i < matchedItems.length; i++) {
      const item = matchedItems[i]
      const prevItem = i > 0 ? matchedItems[i - 1] : null
      const nextItem = i < matchedItems.length - 1 ? matchedItems[i + 1] : null
      
      // Пустий рядок перед пунктами та підпунктами
      if (item.type === 'point' || item.type === 'subpoint') {
        children.push(new Paragraph({
          children: [new TextRun({ text: "", font: "Calibri", size: 28 })],
          alignment: 'both',
          spacing: { after: 0 }
        }))
      }
      
      // Пустий рядок перед ШтрихПунктом, якщо попередній - абзац
      if (item.type === 'dash-point' && prevItem?.type === 'paragraph') {
        children.push(new Paragraph({
          children: [new TextRun({ text: "", font: "Calibri", size: 28 })],
          alignment: 'both',
          spacing: { after: 0 }
        }))
      }
      
      // Основний абзац
      children.push(createParagraphFromItem(item))
      
      // Пустий рядок після пунктів/підпунктів
      if (item.type === 'point' || item.type === 'subpoint') {
        const shouldAddEmptyLine = !(
          item.type === 'point' && 
          nextItem && 
          (nextItem.type === 'subpoint' || nextItem.type === 'dash-point') && 
          nextItem.parent === item
        )
        
        if (shouldAddEmptyLine) {
          children.push(new Paragraph({
            children: [new TextRun({ text: "", font: "Calibri", size: 28 })],
            alignment: 'both',
            spacing: { after: 0 }
          }))
        }
      }
    }
  } else {
    children.push(new Paragraph({ 
      children: [new TextRun({
        text: '— Нічого не знайдено за вказаними ключовими словами —',
        font: { name: 'Calibri' },
        size: 28,
        italics: true
      })],
      alignment: 'both',
      indent: {
        firstLine: 720
      }
    }))
  }
  
  const doc = new Document({
    styles: {
      default: {
        document: {
          run: {
            font: { name: 'Calibri' },
            size: 28
          }
        }
      }
    },
    sections: [{
      properties: {},
      children: children
    }]
  })
  
  const buffer = await Packer.toBuffer(doc)
  
  const dir = path.dirname(outputPath)
  await fs.mkdir(dir, { recursive: true })
  
  await fs.writeFile(outputPath, buffer)
}

// ============================================================================
// ГОЛОВНИЙ ОБРОБНИК IPC
// ============================================================================

ipcMain.handle('order:process', async (e, payload) => {
  try {
    console.log('[order:process] starting...', {
      hasWordBuf: !!payload.wordBuf,
      outputPath: payload.outputPath,
      flags: payload.flags,
      mode: payload.mode || 'default'
    })
    
    // Валідація
    if (!payload.wordBuf) {
      return { ok: false, error: 'Word-шаблон відсутній' }
    }
    
    if (!payload.outputPath) {
      return { ok: false, error: 'Шлях збереження відсутній' }
    }
    
    const results: Array<{type: string, path: string, stats: any}> = []
    
    // Витягнути абзаци з Word
    const { paragraphs: formattedParagraphs, firstLine } = 
      await extractFormattedParagraphsFromWord(payload.wordBuf)
    
    // Розбір структури
    const orderStructure = parseOrderStructure(formattedParagraphs)
    console.log(`[order:process] Розібрано структуру: ${orderStructure.length} основних елементів`)
    
    console.log(`[order:process] Знайдено абзаців: ${formattedParagraphs.length}`)
    console.log(`[order:process] Перша строка: "${firstLine}"`)
    
    // === РЕЖИМ 2БСП ===
    if (payload.flags.is2BSP) {
      try {
        console.log('[order:process] Режим 2БСП: пошук за ключовим словом "2-го батальйону"...')
      
        const matchedItems = findInOrderStructure(orderStructure, "2-го батальйону")
        console.log(`[order:process] Збігів знайдено: ${matchedItems.length}`)
        
        if (matchedItems.length > 0) {
          console.log('[order:process] Перші 3 знайдені елементи:')
          for (let i = 0; i < Math.min(3, matchedItems.length); i++) {
            const item = matchedItems[i]
            console.log(`[order:process] Збіг #${i+1} [${item.type}${item.number ? ` ${item.number}` : ''}]: "${item.text.substring(0, 100)}..."`)
          }
        }
        
        results.push({
          type: '2БСП',
          path: payload.outputPath.replace('.docx', '_2БСП.docx'),
          stats: {
            tokens: 1,
            paragraphs: formattedParagraphs.length,
            matched: matchedItems.length,
            structureElements: orderStructure.length
          }
        })
        
        const bspPath = payload.outputPath.replace('.docx', '_2БСП.docx')
        await createStructuredResultDocument(matchedItems, bspPath, firstLine)
        
      } catch (err: any) {
        console.error('[order:process] 2БСП processing error:', err)
        return { ok: false, error: `2БСП обробка: ${err instanceof Error ? err.message : String(err)}` }
      }
    }
    
    // Автовідкриття
    if (payload.flags.autoOpen && results.length > 0) {
      console.log(`[order:process] Auto-opening ${results.length} document(s)...`)
      for (let i = 0; i < results.length; i++) {
        setTimeout(() => {
          shell.openPath(results[i].path)
          console.log(`[order:process] Auto-opening document ${i+1}/${results.length}: ${results[i].path}`)
        }, 500 * (i + 1))
      }
    }
    
    return {
      ok: true,
      out: results.length > 0 ? results[0].path : payload.outputPath,
      stats: results.length > 0 ? results[0].stats : {},
      results
    }
    
  } catch (error: any) {
    console.error('[order:process] error:', error)
    return { 
      ok: false, 
      error: error.message || 'Невідома помилка обробки' 
    }
  }
})

================================================================================
КІНЕЦЬ КОДУ
================================================================================

КЛЮЧОВІ ОСОБЛИВОСТІ:

1. ШтрихПункт = тільки ПІДКРЕСЛЕНИЙ (БЕЗ жирного шрифту)
   Критерій: hasUnderline && !hasBold

2. Форматування результату:
   - Пункти: жирний
   - Підпункти: жирний
   - ШтрихПункти: тільки підкреслений
   - Абзаци: звичайний

3. Ієрархія зберігається повністю:
   Point → Subpoint → Dash-point → Paragraph

4. Детальне діагностичне логування на кожному етапі

5. Автоматичне відкриття створеного документа (опціонально)
