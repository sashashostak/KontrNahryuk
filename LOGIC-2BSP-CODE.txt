================================================================================
–ü–û–í–ù–ò–ô –ö–û–î –õ–û–ì–Ü–ö–ò 2–ë–°–ü
–î–∞—Ç–∞: 17 –∂–æ–≤—Ç–Ω—è 2025
–§–∞–π–ª: electron/main.ts
================================================================================

// ============================================================================
// –¢–ò–ü–ò –î–ê–ù–ò–•
// ============================================================================

interface OrderItem {
  type: 'point' | 'subpoint' | 'dash-point' | 'paragraph'
  number?: string  // "1", "7.1", "8.3" —Ç–æ—â–æ
  text: string
  html: string
  index: number    // –æ—Ä–∏–≥—ñ–Ω–∞–ª—å–Ω–∏–π —ñ–Ω–¥–µ–∫—Å –≤ –¥–æ–∫—É–º–µ–Ω—Ç—ñ
  children: OrderItem[]
  parent?: OrderItem
  matchedNames?: string[] // –ü–Ü–ë –∑–Ω–∞–π–¥–µ–Ω—ñ –≤ —Ü—å–æ–º—É –µ–ª–µ–º–µ–Ω—Ç—ñ
}

// ============================================================================
// –ö–†–û–ö 1: –ß–ò–¢–ê–ù–ù–Ø –¢–ê –ü–ê–†–°–ò–ù–ì WORD-–î–û–ö–£–ú–ï–ù–¢–ê
// ============================================================================

async function extractFormattedParagraphsFromWord(wordBuf: ArrayBuffer): Promise<{
  paragraphs: Array<{ text: string, html: string, isBoldAndUnderlined: boolean }>,
  firstLine: string
}> {
  try {
    const result = await mammoth.convertToHtml({ 
      buffer: Buffer.from(wordBuf)
    })
    
    // –†–æ–∑–±–∏—Ç–∏ HTML –Ω–∞ –∞–±–∑–∞—Ü–∏, –∑–±–µ—Ä—ñ–≥–∞—é—á–∏ HTML —Ñ–æ—Ä–º–∞—Ç—É–≤–∞–Ω–Ω—è
    const htmlParagraphs = result.value.split(/<\/?p[^>]*>/i).filter(p => p.trim().length > 0)
    
    // === –î–Ü–ê–ì–ù–û–°–¢–ò–ö–ê: –í–∏–≤—ñ–¥ –ø–µ—Ä—à–∏—Ö –∞–±–∑–∞—Ü—ñ–≤ HTML ===
    console.log('[extractFormatted] === –ü–µ—Ä—à—ñ 5 –∞–±–∑–∞—Ü—ñ–≤ HTML ===')
    for (let i = 0; i < Math.min(5, htmlParagraphs.length); i++) {
      console.log(`[extractFormatted] –ê–±–∑–∞—Ü ${i}: ${htmlParagraphs[i].substring(0, 200)}${htmlParagraphs[i].length > 200 ? '...' : ''}`)
    }
    console.log('[extractFormatted] === –ö—ñ–Ω–µ—Ü—å –¥—ñ–∞–≥–Ω–æ—Å—Ç–∏–∫–∏ HTML ===')
    
    const paragraphs = htmlParagraphs.map((htmlPara, index) => {
      const text = htmlPara.replace(/<[^>]+>/g, '').trim()
      const html = htmlPara.trim()
      
      // === –ü–û–ö–†–ê–©–ï–ù–ê –ü–ï–†–ï–í–Ü–†–ö–ê –§–û–†–ú–ê–¢–£–í–ê–ù–ù–Ø ===
      // –®—Ç—Ä–∏—Ö–ü—É–Ω–∫—Ç = —Ç—ñ–ª—å–∫–∏ –ü–Ü–î–ö–†–ï–°–õ–ï–ù–ò–ô (–ë–ï–ó –∂–∏—Ä–Ω–æ–≥–æ)
      
      // –í–∞—Ä—ñ–∞–Ω—Ç 1: –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ —á–µ—Ä–µ–∑ —Ç–µ–≥–∏
      const hasBoldTag = /<(strong|b)(\s|>|\/)/i.test(html)
      const hasUnderlineTag = /<u(\s|>|\/)/i.test(html)
      
      // –í–∞—Ä—ñ–∞–Ω—Ç 2: –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ —á–µ—Ä–µ–∑ inline —Å—Ç–∏–ª—ñ (–¥–ª—è mammoth)
      const hasBoldStyle = /font-weight\s*:\s*bold/i.test(html)
      const hasUnderlineStyle = /text-decoration\s*:\s*underline/i.test(html)
      
      // –ö–æ–º–±—ñ–Ω–æ–≤–∞–Ω–∞ –ø–µ—Ä–µ–≤—ñ—Ä–∫–∞
      const hasBold = hasBoldTag || hasBoldStyle
      const hasUnderline = hasUnderlineTag || hasUnderlineStyle
      
      // –®—Ç—Ä–∏—Ö–ü—É–Ω–∫—Ç = –ø—ñ–¥–∫—Ä–µ—Å–ª–µ–Ω–∏–π –ë–ï–ó –∂–∏—Ä–Ω–æ–≥–æ
      const isBoldAndUnderlined = hasUnderline && !hasBold
      
      // === –ö–†–ò–¢–ò–ß–ù–û: –î–Ü–ê–ì–ù–û–°–¢–ò–ß–ù–ï –õ–û–ì–£–í–ê–ù–ù–Ø ===
      if (isBoldAndUnderlined) {
        console.log(`[extractFormatted] ‚úÖ –ó–Ω–∞–π–¥–µ–Ω–æ –®—Ç—Ä–∏—Ö–ü—É–Ω–∫—Ç (–ø—ñ–¥–∫—Ä–µ—Å–ª–µ–Ω–∏–π –ë–ï–ó –∂–∏—Ä–Ω–æ–≥–æ) –Ω–∞ –ø–æ–∑–∏—Ü—ñ—ó ${index}:`)
        console.log(`[extractFormatted]    –¢–µ–∫—Å—Ç: "${text.substring(0, 60)}..."`)
        console.log(`[extractFormatted]    HTML: ${html.substring(0, 150)}...`)
        console.log(`[extractFormatted]    Bold: ${hasBold} (tag: ${hasBoldTag}, style: ${hasBoldStyle})`)
        console.log(`[extractFormatted]    Underline: ${hasUnderline} (tag: ${hasUnderlineTag}, style: ${hasUnderlineStyle})`)
      } else if (text.length > 0 && text.length < 100 && (hasBold || hasUnderline)) {
        // –õ–æ–≥—É–≤–∞–Ω–Ω—è –ø–æ—Ç–µ–Ω—Ü—ñ–π–Ω–∏—Ö –®—Ç—Ä–∏—Ö–ü—É–Ω–∫—Ç—ñ–≤, —è–∫—ñ –º–∞–π–∂–µ –ø—ñ–¥—Ö–æ–¥—è—Ç—å
        console.log(`[extractFormatted] ‚ö†Ô∏è  –ü–æ—Ç–µ–Ω—Ü—ñ–π–Ω–∏–π –®—Ç—Ä–∏—Ö–ü—É–Ω–∫—Ç (–Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω–µ —Ñ–æ—Ä–º–∞—Ç—É–≤–∞–Ω–Ω—è) –Ω–∞ –ø–æ–∑–∏—Ü—ñ—ó ${index}:`)
        console.log(`[extractFormatted]    –¢–µ–∫—Å—Ç: "${text.substring(0, 60)}..."`)
        console.log(`[extractFormatted]    HTML: ${html.substring(0, 150)}...`)
        console.log(`[extractFormatted]    Bold: ${hasBold}, Underline: ${hasUnderline}`)
        console.log(`[extractFormatted]    ‚ùå –û—á—ñ–∫—É—î—Ç—å—Å—è: Underline=true —ñ Bold=false`)
      }
      
      return {
        text,
        html,
        isBoldAndUnderlined
      }
    }).filter(p => p.text.length > 0)
    
    // –ü–µ—Ä—à–∞ —Å—Ç—Ä–æ–∫–∞ (–ø–µ—Ä—à–∏–π –∞–±–∑–∞—Ü)
    const firstLine = paragraphs.length > 0 ? paragraphs[0].text : ''
    
    console.log(`[extractFormatted] –ó–∞–≥–∞–ª–æ–º –∑–Ω–∞–π–¥–µ–Ω–æ –®—Ç—Ä–∏—Ö–ü—É–Ω–∫—Ç—ñ–≤: ${paragraphs.filter(p => p.isBoldAndUnderlined).length}`)
    
    return { paragraphs, firstLine }
  } catch (err) {
    throw new Error(`–ü–æ–º–∏–ª–∫–∞ —á–∏—Ç–∞–Ω–Ω—è Word: ${err instanceof Error ? err.message : String(err)}`)
  }
}

// ============================================================================
// –ö–†–û–ö 2: –†–û–ó–ë–Ü–† –°–¢–†–£–ö–¢–£–†–ò –ù–ê–ö–ê–ó–£
// ============================================================================

function parseOrderStructure(paragraphs: Array<{ text: string, html: string, isBoldAndUnderlined: boolean }>): OrderItem[] {
  const structure: OrderItem[] = []
  let currentPoint: OrderItem | null = null
  let currentSubpoint: OrderItem | null = null
  let currentDashPoint: OrderItem | null = null
  
  for (let i = 0; i < paragraphs.length; i++) {
    const para = paragraphs[i]
    const text = para.text.trim()
    const html = para.html.trim()
    const isBoldAndUnderlined = para.isBoldAndUnderlined
    
    // –†–æ–∑–ø—ñ–∑–Ω–∞–≤–∞–Ω–Ω—è –æ—Å–Ω–æ–≤–Ω–∏—Ö –ø—É–Ω–∫—Ç—ñ–≤ (1, 2, 3, ... –∞–±–æ 1., 2., 3., ...)
    const pointMatch = text.match(/^(\d+)\.?\s+(.+)/) && !text.match(/^\d+\.\d+/)
    if (pointMatch) {
      const matches = text.match(/^(\d+)\.?\s+(.+)/)
      const pointNumber = matches![1]
      const pointText = matches![2]
      
      console.log(`[parseOrderStructure] –ó–Ω–∞–π–¥–µ–Ω–æ –ø—É–Ω–∫—Ç ${pointNumber}: "${pointText.substring(0, 50)}..."`)
      
      currentPoint = {
        type: 'point',
        number: pointNumber,
        text: text,
        html: html,
        index: i,
        children: []
      }
      structure.push(currentPoint)
      currentSubpoint = null
      currentDashPoint = null
      continue
    }
    
    // –†–æ–∑–ø—ñ–∑–Ω–∞–≤–∞–Ω–Ω—è –ø—ñ–¥–ø—É–Ω–∫—Ç—ñ–≤ (7.1, 8.3, ... –∞–±–æ 7.1., 8.3., ...)
    const subpointMatch = text.match(/^(\d+\.\d+)\.?\s+(.+)/)
    if (subpointMatch) {
      const subpointNumber = subpointMatch[1]
      const subpointText = subpointMatch[2]
      
      console.log(`[parseOrderStructure] –ó–Ω–∞–π–¥–µ–Ω–æ –ø—ñ–¥–ø—É–Ω–∫—Ç ${subpointNumber}: "${subpointText.substring(0, 50)}..."`)
      
      currentSubpoint = {
        type: 'subpoint',
        number: subpointNumber,
        text: text,
        html: html,
        index: i,
        children: [],
        parent: currentPoint || undefined
      }
      
      if (currentPoint) {
        currentPoint.children.push(currentSubpoint)
      } else {
        structure.push(currentSubpoint)
      }
      currentDashPoint = null
      continue
    }
    
    // –†–æ–∑–ø—ñ–∑–Ω–∞–≤–∞–Ω–Ω—è –®—Ç—Ä–∏—Ö–ü—É–Ω–∫—Ç—É (—Ç—ñ–ª—å–∫–∏ –ø—ñ–¥–∫—Ä–µ—Å–ª–µ–Ω–∏–π, –±–µ–∑ —á–∏—Å–ª–æ–≤–æ—ó –Ω—É–º–µ—Ä–∞—Ü—ñ—ó)
    if (isBoldAndUnderlined) {
      // === –î–û–î–ê–¢–ö–û–í–ê –í–ê–õ–Ü–î–ê–¶–Ü–Ø ===
      
      // –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ 1: –ù–µ —î –ø—É–Ω–∫—Ç–æ–º –∑ –Ω–æ–º–µ—Ä–æ–º
      const isNumberedPoint = /^\d+\.?\s/.test(text)
      const isNumberedSubpoint = /^\d+\.\d+\.?\s/.test(text)
      
      if (isNumberedPoint || isNumberedSubpoint) {
        console.log(`[parseOrderStructure] ‚ö†Ô∏è  –ü—Ä–æ–ø—É—â–µ–Ω–æ: —Ç–µ–∫—Å—Ç "${text.substring(0, 40)}..." –º–∞—î —Ñ–æ—Ä–º–∞—Ç—É–≤–∞–Ω–Ω—è –®—Ç—Ä–∏—Ö–ü—É–Ω–∫—Ç—É, –∞–ª–µ —Ü–µ –Ω—É–º–µ—Ä–æ–≤–∞–Ω–∏–π –ø—É–Ω–∫—Ç`)
        continue
      }
      
      // –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ 2: –ù–µ –∑–∞–Ω–∞–¥—Ç–æ –¥–æ–≤–≥–∏–π (–®—Ç—Ä–∏—Ö–ü—É–Ω–∫—Ç–∏ –∑–∞–∑–≤–∏—á–∞–π –∫–æ—Ä–æ—Ç–∫—ñ)
      if (text.length > 200) {
        console.log(`[parseOrderStructure] ‚ö†Ô∏è  –ü—Ä–æ–ø—É—â–µ–Ω–æ: —Ç–µ–∫—Å—Ç "${text.substring(0, 40)}..." –Ω–∞–¥—Ç–æ –¥–æ–≤–≥–∏–π –¥–ª—è –®—Ç—Ä–∏—Ö–ü—É–Ω–∫—Ç—É (${text.length} —Å–∏–º–≤–æ–ª—ñ–≤)`)
      } else {
        console.log(`[parseOrderStructure] ‚úÖ –ó–Ω–∞–π–¥–µ–Ω–æ –®—Ç—Ä–∏—Ö–ü—É–Ω–∫—Ç –Ω–∞ –ø–æ–∑–∏—Ü—ñ—ó ${i}: "${text.substring(0, 50)}..."`)
        
        const dashpoint: OrderItem = {
          type: 'dash-point',
          text: text,
          html: html,
          index: i,
          children: [],
          parent: currentSubpoint || currentPoint || undefined
        }
        
        if (currentSubpoint) {
          currentSubpoint.children.push(dashpoint)
          console.log(`[parseOrderStructure]    ‚Üí –î–æ–¥–∞–Ω–æ —è–∫ –¥–æ—á—ñ—Ä–Ω—ñ–π –µ–ª–µ–º–µ–Ω—Ç –ø—ñ–¥–ø—É–Ω–∫—Ç—É ${currentSubpoint.number}`)
        } else if (currentPoint) {
          currentPoint.children.push(dashpoint)
          console.log(`[parseOrderStructure]    ‚Üí –î–æ–¥–∞–Ω–æ —è–∫ –¥–æ—á—ñ—Ä–Ω—ñ–π –µ–ª–µ–º–µ–Ω—Ç –ø—É–Ω–∫—Ç—É ${currentPoint.number}`)
        } else {
          structure.push(dashpoint)
          console.log(`[parseOrderStructure]    ‚Üí –£–í–ê–ì–ê: –®—Ç—Ä–∏—Ö–ü—É–Ω–∫—Ç –Ω–µ –º–∞—î –±–∞—Ç—å–∫–∞, –¥–æ–¥–∞–Ω–æ –¥–æ –∫–æ—Ä–µ–Ω—è`)
        }
        
        currentDashPoint = dashpoint
        continue
      }
    }
    
    // –ó–≤–∏—á–∞–π–Ω—ñ –∞–±–∑–∞—Ü–∏
    const paragraph: OrderItem = {
      type: 'paragraph',
      text: text,
      html: html,
      index: i,
      children: [],
      parent: currentDashPoint || currentSubpoint || currentPoint || undefined
    }
    
    if (currentDashPoint) {
      currentDashPoint.children.push(paragraph)
    } else if (currentSubpoint) {
      currentSubpoint.children.push(paragraph)
    } else if (currentPoint) {
      currentPoint.children.push(paragraph)
    } else {
      structure.push(paragraph)
    }
  }
  
  // === –î–Ü–ê–ì–ù–û–°–¢–ò–ß–ù–ò–ô –í–ò–í–Ü–î –°–¢–†–£–ö–¢–£–†–ò ===
  console.log('[parseOrderStructure] === –°–¢–†–£–ö–¢–£–†–ê –î–û–ö–£–ú–ï–ù–¢–ê ===')
  function printStructure(items: OrderItem[], depth = 0) {
    for (const item of items) {
      const indent = '  '.repeat(depth)
      const typeLabel = item.type === 'dash-point' ? '‚≠ê dash-point' : item.type
      console.log(`${indent}${typeLabel}${item.number ? ` ${item.number}` : ''}: "${item.text.substring(0, 40)}..." (index: ${item.index})`)
      if (item.children.length > 0) {
        printStructure(item.children, depth + 1)
      }
    }
  }
  printStructure(structure)
  console.log('[parseOrderStructure] === –ö–Ü–ù–ï–¶–¨ –°–¢–†–£–ö–¢–£–†–ò ===')
  
  return structure
}

// ============================================================================
// –ö–†–û–ö 3: –ü–û–®–£–ö –ó–ë–Ü–ì–Ü–í –ó–ê –ö–õ–Æ–ß–û–í–ò–ú –°–õ–û–í–û–ú
// ============================================================================

function findInOrderStructure(structure: OrderItem[], keyword: string): OrderItem[] {
  const results: OrderItem[] = []
  const addedIndices = new Set<number>()
  const normalizedKeyword = keyword.toLowerCase()
  
  const norm = (text: string) => text.toLowerCase()
  
  // === –°–¢–ê–¢–ò–°–¢–ò–ö–ê –î–õ–Ø –î–Ü–ê–ì–ù–û–°–¢–ò–ö–ò ===
  let foundParagraphs = 0
  let foundPoints = 0
  let foundSubpoints = 0
  let foundDashPoints = 0
  
  function addWithHierarchy(item: OrderItem): void {
    // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –¥–æ–¥–∞–≤–∞–Ω–Ω—è –µ–ª–µ–º–µ–Ω—Ç–∞ —Ä–∞–∑–æ–º –∑ —É—Å—ñ—î—é –π–æ–≥–æ —ñ—î—Ä–∞—Ä—Ö—ñ—î—é –±–∞—Ç—å–∫—ñ–≤
    const hierarchyChain: OrderItem[] = []
    
    // –ó–±–∏—Ä–∞—î–º–æ –≤—Å—é —ñ—î—Ä–∞—Ä—Ö—ñ—é –≤—ñ–¥ –µ–ª–µ–º–µ–Ω—Ç–∞ –¥–æ –∫–æ—Ä–µ–Ω—è
    let current: OrderItem | undefined = item
    while (current) {
      hierarchyChain.unshift(current)
      current = current.parent
    }
    
    // === –õ–û–ì–£–í–ê–ù–ù–Ø –Ü–Ñ–†–ê–†–•–Ü–á ===
    console.log(`[findInOrderStructure] –î–æ–¥–∞–≤–∞–Ω–Ω—è —ñ—î—Ä–∞—Ä—Ö—ñ—ó –¥–ª—è "${item.text.substring(0, 40)}...":`)
    for (const h of hierarchyChain) {
      console.log(`[findInOrderStructure]   ${h.type}${h.number ? ` ${h.number}` : ''}: "${h.text.substring(0, 40)}..."`)
    }
    
    // –î–æ–¥–∞—î–º–æ –≤—Å—ñ –µ–ª–µ–º–µ–Ω—Ç–∏ —ñ—î—Ä–∞—Ä—Ö—ñ—ó, —É–Ω–∏–∫–∞—é—á–∏ –¥—É–±–ª—ñ–≤
    for (const hierarchyItem of hierarchyChain) {
      if (!addedIndices.has(hierarchyItem.index)) {
        results.push(hierarchyItem)
        addedIndices.add(hierarchyItem.index)
        
        // –ü—ñ–¥—Ä–∞—Ö—É–Ω–æ–∫ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
        if (hierarchyItem.type === 'dash-point') {
          foundDashPoints++
          console.log(`[findInOrderStructure]   ‚úÖ –î–æ–¥–∞–Ω–æ –®—Ç—Ä–∏—Ö–ü—É–Ω–∫—Ç: "${hierarchyItem.text.substring(0, 40)}..."`)
        } else if (hierarchyItem.type === 'point') {
          foundPoints++
        } else if (hierarchyItem.type === 'subpoint') {
          foundSubpoints++
        } else if (hierarchyItem.type === 'paragraph') {
          foundParagraphs++
        }
      }
    }
  }
  
  function searchRecursive(items: OrderItem[]): void {
    for (const item of items) {
      const normalizedText = norm(item.text)
      
      if (normalizedText.includes(normalizedKeyword)) {
        console.log(`[findInOrderStructure] üéØ –ó–Ω–∞–π–¥–µ–Ω–æ –∑–±—ñ–≥ –≤ ${item.type}${item.number ? ` ${item.number}` : ''}: "${item.text.substring(0, 60)}..."`)
        
        if (item.parent) {
          console.log(`[findInOrderStructure]    –ë–∞—Ç—å–∫–æ: ${item.parent.type}${item.parent.number ? ` ${item.parent.number}` : ''}: "${item.parent.text.substring(0, 40)}..."`)
        }
        
        addWithHierarchy(item)
      }
      
      // –†–µ–∫—É—Ä—Å–∏–≤–Ω–∏–π –ø–æ—à—É–∫ –≤ –¥–æ—á—ñ—Ä–Ω—ñ—Ö –µ–ª–µ–º–µ–Ω—Ç–∞—Ö
      if (item.children.length > 0) {
        searchRecursive(item.children)
      }
    }
  }
  
  searchRecursive(structure)
  
  // === –§–Ü–ù–ê–õ–¨–ù–ê –°–¢–ê–¢–ò–°–¢–ò–ö–ê ===
  console.log(`[findInOrderStructure] === –°–¢–ê–¢–ò–°–¢–ò–ö–ê –ü–û–®–£–ö–£ ===`)
  console.log(`[findInOrderStructure] –í—Å—å–æ–≥–æ –µ–ª–µ–º–µ–Ω—Ç—ñ–≤ –≤ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ñ: ${results.length}`)
  console.log(`[findInOrderStructure]   - –ü—É–Ω–∫—Ç—ñ–≤: ${foundPoints}`)
  console.log(`[findInOrderStructure]   - –ü—ñ–¥–ø—É–Ω–∫—Ç—ñ–≤: ${foundSubpoints}`)
  console.log(`[findInOrderStructure]   - –®—Ç—Ä–∏—Ö–ü—É–Ω–∫—Ç—ñ–≤: ${foundDashPoints} ‚≠ê`)
  console.log(`[findInOrderStructure]   - –ê–±–∑–∞—Ü—ñ–≤: ${foundParagraphs}`)
  
  // –°–æ—Ä—Ç—É—î–º–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∏ –∑–∞ –æ—Ä–∏–≥—ñ–Ω–∞–ª—å–Ω–∏–º –ø–æ—Ä—è–¥–∫–æ–º –≤ –¥–æ–∫—É–º–µ–Ω—Ç—ñ
  return results.sort((a, b) => a.index - b.index)
}

// ============================================================================
// –ö–†–û–ö 4: –°–¢–í–û–†–ï–ù–ù–Ø –†–ï–ó–£–õ–¨–¢–£–Æ–ß–û–ì–û –î–û–ö–£–ú–ï–ù–¢–ê
// ============================================================================

async function createStructuredResultDocument(
  matchedItems: OrderItem[], 
  outputPath: string, 
  firstLine?: string
): Promise<void> {
  const children = []
  
  // –î–æ–¥–∞—Ç–∏ –ø–µ—Ä—à—É —Å—Ç—Ä–æ–∫—É –Ω–∞–∫–∞–∑—É, —è–∫—â–æ —î
  if (firstLine) {
    children.push(new Paragraph({ 
      children: [new TextRun({
        text: firstLine,
        font: { name: 'Calibri' },
        size: 28 // 14pt
      })],
      alignment: 'both',
      indent: {
        firstLine: 720
      },
      spacing: { after: 200 }
    }))
  }
  
  // –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü—ñ—ó OrderItem –≤ Paragraph
  function createParagraphFromItem(item: OrderItem): Paragraph {
    let displayText = item.text
    
    if (item.number && (item.type === 'point' || item.type === 'subpoint')) {
      const cleanText = item.text.replace(/^\d+(\.\d+)?\.?\s*/, '')
      displayText = `${item.number}. ${cleanText}`
    }
    
    // –í–∏–∑–Ω–∞—á–∏—Ç–∏ —Ñ–æ—Ä–º–∞—Ç—É–≤–∞–Ω–Ω—è –∑–∞–ª–µ–∂–Ω–æ –≤—ñ–¥ —Ç–∏–ø—É
    // –®—Ç—Ä–∏—Ö–ü—É–Ω–∫—Ç = —Ç—ñ–ª—å–∫–∏ –ø—ñ–¥–∫—Ä–µ—Å–ª–µ–Ω–∏–π (–ë–ï–ó –∂–∏—Ä–Ω–æ–≥–æ)
    const isBold = item.type === 'point' || item.type === 'subpoint'
    const isUnderline = item.type === 'dash-point'
    
    const textRun = new TextRun({
      text: displayText,
      font: "Calibri",
      size: 28,
      bold: isBold,
      underline: isUnderline ? { type: 'single' } : undefined
    })
    
    return new Paragraph({
      children: [textRun],
      alignment: 'both',
      indent: {
        firstLine: 720
      }
    })
  }
  
  // –î–æ–¥–∞—Ç–∏ –∑–Ω–∞–π–¥–µ–Ω—ñ –µ–ª–µ–º–µ–Ω—Ç–∏
  if (matchedItems.length > 0) {
    for (let i = 0; i < matchedItems.length; i++) {
      const item = matchedItems[i]
      const prevItem = i > 0 ? matchedItems[i - 1] : null
      const nextItem = i < matchedItems.length - 1 ? matchedItems[i + 1] : null
      
      // –ü—É—Å—Ç–∏–π —Ä—è–¥–æ–∫ –ø–µ—Ä–µ–¥ –ø—É–Ω–∫—Ç–∞–º–∏ —Ç–∞ –ø—ñ–¥–ø—É–Ω–∫—Ç–∞–º–∏
      if (item.type === 'point' || item.type === 'subpoint') {
        children.push(new Paragraph({
          children: [new TextRun({ text: "", font: "Calibri", size: 28 })],
          alignment: 'both',
          spacing: { after: 0 }
        }))
      }
      
      // –ü—É—Å—Ç–∏–π —Ä—è–¥–æ–∫ –ø–µ—Ä–µ–¥ –®—Ç—Ä–∏—Ö–ü—É–Ω–∫—Ç–æ–º, —è–∫—â–æ –ø–æ–ø–µ—Ä–µ–¥–Ω—ñ–π - –∞–±–∑–∞—Ü
      if (item.type === 'dash-point' && prevItem?.type === 'paragraph') {
        children.push(new Paragraph({
          children: [new TextRun({ text: "", font: "Calibri", size: 28 })],
          alignment: 'both',
          spacing: { after: 0 }
        }))
      }
      
      // –û—Å–Ω–æ–≤–Ω–∏–π –∞–±–∑–∞—Ü
      children.push(createParagraphFromItem(item))
      
      // –ü—É—Å—Ç–∏–π —Ä—è–¥–æ–∫ –ø—ñ—Å–ª—è –ø—É–Ω–∫—Ç—ñ–≤/–ø—ñ–¥–ø—É–Ω–∫—Ç—ñ–≤
      if (item.type === 'point' || item.type === 'subpoint') {
        const shouldAddEmptyLine = !(
          item.type === 'point' && 
          nextItem && 
          (nextItem.type === 'subpoint' || nextItem.type === 'dash-point') && 
          nextItem.parent === item
        )
        
        if (shouldAddEmptyLine) {
          children.push(new Paragraph({
            children: [new TextRun({ text: "", font: "Calibri", size: 28 })],
            alignment: 'both',
            spacing: { after: 0 }
          }))
        }
      }
    }
  } else {
    children.push(new Paragraph({ 
      children: [new TextRun({
        text: '‚Äî –ù—ñ—á–æ–≥–æ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ –∑–∞ –≤–∫–∞–∑–∞–Ω–∏–º–∏ –∫–ª—é—á–æ–≤–∏–º–∏ —Å–ª–æ–≤–∞–º–∏ ‚Äî',
        font: { name: 'Calibri' },
        size: 28,
        italics: true
      })],
      alignment: 'both',
      indent: {
        firstLine: 720
      }
    }))
  }
  
  const doc = new Document({
    styles: {
      default: {
        document: {
          run: {
            font: { name: 'Calibri' },
            size: 28
          }
        }
      }
    },
    sections: [{
      properties: {},
      children: children
    }]
  })
  
  const buffer = await Packer.toBuffer(doc)
  
  const dir = path.dirname(outputPath)
  await fs.mkdir(dir, { recursive: true })
  
  await fs.writeFile(outputPath, buffer)
}

// ============================================================================
// –ì–û–õ–û–í–ù–ò–ô –û–ë–†–û–ë–ù–ò–ö IPC
// ============================================================================

ipcMain.handle('order:process', async (e, payload) => {
  try {
    console.log('[order:process] starting...', {
      hasWordBuf: !!payload.wordBuf,
      outputPath: payload.outputPath,
      flags: payload.flags,
      mode: payload.mode || 'default'
    })
    
    // –í–∞–ª—ñ–¥–∞—Ü—ñ—è
    if (!payload.wordBuf) {
      return { ok: false, error: 'Word-—à–∞–±–ª–æ–Ω –≤—ñ–¥—Å—É—Ç–Ω—ñ–π' }
    }
    
    if (!payload.outputPath) {
      return { ok: false, error: '–®–ª—è—Ö –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è –≤—ñ–¥—Å—É—Ç–Ω—ñ–π' }
    }
    
    const results: Array<{type: string, path: string, stats: any}> = []
    
    // –í–∏—Ç—è–≥–Ω—É—Ç–∏ –∞–±–∑–∞—Ü–∏ –∑ Word
    const { paragraphs: formattedParagraphs, firstLine } = 
      await extractFormattedParagraphsFromWord(payload.wordBuf)
    
    // –†–æ–∑–±—ñ—Ä —Å—Ç—Ä—É–∫—Ç—É—Ä–∏
    const orderStructure = parseOrderStructure(formattedParagraphs)
    console.log(`[order:process] –†–æ–∑—ñ–±—Ä–∞–Ω–æ —Å—Ç—Ä—É–∫—Ç—É—Ä—É: ${orderStructure.length} –æ—Å–Ω–æ–≤–Ω–∏—Ö –µ–ª–µ–º–µ–Ω—Ç—ñ–≤`)
    
    console.log(`[order:process] –ó–Ω–∞–π–¥–µ–Ω–æ –∞–±–∑–∞—Ü—ñ–≤: ${formattedParagraphs.length}`)
    console.log(`[order:process] –ü–µ—Ä—à–∞ —Å—Ç—Ä–æ–∫–∞: "${firstLine}"`)
    
    // === –†–ï–ñ–ò–ú 2–ë–°–ü ===
    if (payload.flags.is2BSP) {
      try {
        console.log('[order:process] –†–µ–∂–∏–º 2–ë–°–ü: –ø–æ—à—É–∫ –∑–∞ –∫–ª—é—á–æ–≤–∏–º —Å–ª–æ–≤–æ–º "2-–≥–æ –±–∞—Ç–∞–ª—å–π–æ–Ω—É"...')
      
        const matchedItems = findInOrderStructure(orderStructure, "2-–≥–æ –±–∞—Ç–∞–ª—å–π–æ–Ω—É")
        console.log(`[order:process] –ó–±—ñ–≥—ñ–≤ –∑–Ω–∞–π–¥–µ–Ω–æ: ${matchedItems.length}`)
        
        if (matchedItems.length > 0) {
          console.log('[order:process] –ü–µ—Ä—à—ñ 3 –∑–Ω–∞–π–¥–µ–Ω—ñ –µ–ª–µ–º–µ–Ω—Ç–∏:')
          for (let i = 0; i < Math.min(3, matchedItems.length); i++) {
            const item = matchedItems[i]
            console.log(`[order:process] –ó–±—ñ–≥ #${i+1} [${item.type}${item.number ? ` ${item.number}` : ''}]: "${item.text.substring(0, 100)}..."`)
          }
        }
        
        results.push({
          type: '2–ë–°–ü',
          path: payload.outputPath.replace('.docx', '_2–ë–°–ü.docx'),
          stats: {
            tokens: 1,
            paragraphs: formattedParagraphs.length,
            matched: matchedItems.length,
            structureElements: orderStructure.length
          }
        })
        
        const bspPath = payload.outputPath.replace('.docx', '_2–ë–°–ü.docx')
        await createStructuredResultDocument(matchedItems, bspPath, firstLine)
        
      } catch (err: any) {
        console.error('[order:process] 2–ë–°–ü processing error:', err)
        return { ok: false, error: `2–ë–°–ü –æ–±—Ä–æ–±–∫–∞: ${err instanceof Error ? err.message : String(err)}` }
      }
    }
    
    // –ê–≤—Ç–æ–≤—ñ–¥–∫—Ä–∏—Ç—Ç—è
    if (payload.flags.autoOpen && results.length > 0) {
      console.log(`[order:process] Auto-opening ${results.length} document(s)...`)
      for (let i = 0; i < results.length; i++) {
        setTimeout(() => {
          shell.openPath(results[i].path)
          console.log(`[order:process] Auto-opening document ${i+1}/${results.length}: ${results[i].path}`)
        }, 500 * (i + 1))
      }
    }
    
    return {
      ok: true,
      out: results.length > 0 ? results[0].path : payload.outputPath,
      stats: results.length > 0 ? results[0].stats : {},
      results
    }
    
  } catch (error: any) {
    console.error('[order:process] error:', error)
    return { 
      ok: false, 
      error: error.message || '–ù–µ–≤—ñ–¥–æ–º–∞ –ø–æ–º–∏–ª–∫–∞ –æ–±—Ä–æ–±–∫–∏' 
    }
  }
})

================================================================================
–ö–Ü–ù–ï–¶–¨ –ö–û–î–£
================================================================================

–ö–õ–Æ–ß–û–í–Ü –û–°–û–ë–õ–ò–í–û–°–¢–Ü:

1. –®—Ç—Ä–∏—Ö–ü—É–Ω–∫—Ç = —Ç—ñ–ª—å–∫–∏ –ü–Ü–î–ö–†–ï–°–õ–ï–ù–ò–ô (–ë–ï–ó –∂–∏—Ä–Ω–æ–≥–æ —à—Ä–∏—Ñ—Ç—É)
   –ö—Ä–∏—Ç–µ—Ä—ñ–π: hasUnderline && !hasBold

2. –§–æ—Ä–º–∞—Ç—É–≤–∞–Ω–Ω—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç—É:
   - –ü—É–Ω–∫—Ç–∏: –∂–∏—Ä–Ω–∏–π
   - –ü—ñ–¥–ø—É–Ω–∫—Ç–∏: –∂–∏—Ä–Ω–∏–π
   - –®—Ç—Ä–∏—Ö–ü—É–Ω–∫—Ç–∏: —Ç—ñ–ª—å–∫–∏ –ø—ñ–¥–∫—Ä–µ—Å–ª–µ–Ω–∏–π
   - –ê–±–∑–∞—Ü–∏: –∑–≤–∏—á–∞–π–Ω–∏–π

3. –Ü—î—Ä–∞—Ä—Ö—ñ—è –∑–±–µ—Ä—ñ–≥–∞—î—Ç—å—Å—è –ø–æ–≤–Ω—ñ—Å—Ç—é:
   Point ‚Üí Subpoint ‚Üí Dash-point ‚Üí Paragraph

4. –î–µ—Ç–∞–ª—å–Ω–µ –¥—ñ–∞–≥–Ω–æ—Å—Ç–∏—á–Ω–µ –ª–æ–≥—É–≤–∞–Ω–Ω—è –Ω–∞ –∫–æ–∂–Ω–æ–º—É –µ—Ç–∞–ø—ñ

5. –ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–µ –≤—ñ–¥–∫—Ä–∏—Ç—Ç—è —Å—Ç–≤–æ—Ä–µ–Ω–æ–≥–æ –¥–æ–∫—É–º–µ–Ω—Ç–∞ (–æ–ø—Ü—ñ–æ–Ω–∞–ª—å–Ω–æ)
