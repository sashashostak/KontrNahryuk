AUTOMATIC UPDATE FLOW (KontrNahryuk v1.4.1)
==========================================

Overview
--------
The auto-update system is implemented in three layers:
1. Main-process service (`electron/services/updateService.ts`) that talks to GitHub and manages update state.
2. IPC handlers (`electron/main.ts`) that expose update operations to the renderer.
3. Renderer manager (`src/UpdateManager.ts` + UI) that drives the user experience.

1. UpdateService (main process)
-------------------------------
Initialization reads the current application version directly from the packaged app:

```
constructor(storage: any) {
  super()
  this.storage = storage
  this.currentVersion = app.getVersion()
  this.updateBasePath = join(localAppData, 'UkrainianDocumentProcessor')
  ...
}
```

GitHub releases are fetched through the public REST API. The response is compared with the local version using numeric comparison on major/minor/patch segments:

```
async checkForUpdatesViaGitHub(): Promise<any> {
  const response = await fetch('https://api.github.com/repos/sashashostak/KontrNahryuk/releases/latest', {
    method: 'GET',
    headers: {
      'User-Agent': `KontrNahryuk/${this.currentVersion}`,
      'Accept': 'application/vnd.github.v3+json'
    },
    timeout: 10000
  })

  const release = await response.json()
  const latestVersion = release.tag_name || release.name || 'unknown'
  const hasUpdate = this.isNewerVersion(latestVersion, this.currentVersion)

  return {
    hasUpdate,
    latestVersion,
    currentVersion: this.currentVersion,
    releaseInfo: hasUpdate ? release : null,
    error: null
  }
}
```

Version comparison strips the v-prefix and pads shorter version strings before comparing individual segments:

```
private isNewerVersion(remoteVersion: string, currentVersion: string): boolean {
  const cleanRemote = remoteVersion.replace(/^[vV]/, '').trim()
  const cleanCurrent = currentVersion.replace(/^[vV]/, '').trim()

  const remoteParts = cleanRemote.split('.').map(part => parseInt(part.replace(/[^\d]/g, ''), 10) || 0)
  const currentParts = cleanCurrent.split('.').map(part => parseInt(part.replace(/[^\d]/g, ''), 10) || 0)

  while (remoteParts.length < 3) remoteParts.push(0)
  while (currentParts.length < 3) currentParts.push(0)

  for (let i = 0; i < 3; i++) {
    if (remoteParts[i] > currentParts[i]) return true
    if (remoteParts[i] < currentParts[i]) return false
  }

  return false
}
```

When auto-download is requested, the service looks for a portable ZIP asset in the release and downloads it to the user's Downloads folder:

```
async downloadFromGitHub(asset: any): Promise<string | false> {
  const response = await fetch(asset.browser_download_url, {
    method: 'GET',
    headers: {
      'User-Agent': `KontrNahryuk/${this.currentVersion}`,
      'Accept': 'application/octet-stream'
    }
  })

  const downloadsPath = path.join(os.homedir(), 'Downloads')
  if (!fs.existsSync(downloadsPath)) {
    fs.mkdirSync(downloadsPath, { recursive: true })
  }

  const filePath = path.join(downloadsPath, asset.name)
  const buffer = await response.arrayBuffer()
  fs.writeFileSync(filePath, Buffer.from(buffer))
  shell.showItemInFolder(filePath)
  return filePath
}
```

2. IPC bridge (main.ts)
-----------------------
The main process registers IPC handlers so the renderer can request update operations:

```
ipcMain.handle('updates:get-version', () => {
  return updateService.getCurrentVersion()
})

ipcMain.handle('updates:check-github', async () => {
  return await updateService.checkForUpdatesViaGitHub()
})

ipcMain.handle('updates:download-and-install', async (_, updateInfo) => {
  const releaseInfo = updateInfo.releaseInfo
  const portableAsset = releaseInfo.assets?.find((asset: any) =>
    asset.name.toLowerCase().includes('portable') && asset.name.endsWith('.zip')
  )

  if (!portableAsset) {
    shell.openExternal(releaseInfo.html_url)
    throw new Error('Автоматичне оновлення недоступне. Відкрито сторінку для ручного завантаження.')
  }

  const result = await updateService.downloadFromGitHub(portableAsset)
  return { success: !!result, path: result }
})
```

3. Renderer integration (UpdateManager)
---------------------------------------
Renderer code displays the current version and initiates update checks via the exposed IPC API:

```
const version = await window.api?.invoke?.('updates:get-version') || '1.4.1'
const versionEl = byId('current-version')
if (versionEl) versionEl.textContent = version

const updateInfo = await window.api?.invoke?.('updates:check-github')
if (updateInfo?.hasUpdate) {
  // показуємо секцію про доступне оновлення та кнопку завантаження
}
```

Pressing the "Download" button triggers the download flow through IPC:

```
byId('btn-auto-update')?.addEventListener('click', async () => {
  const result = await window.api?.invoke?.('updates:download-and-install', this.currentUpdateInfo)
  if (!result?.success) {
    // показати повідомлення про помилку або відкрити сторінку релізу
  }
})
```

Licensing check
---------------
Before any update request the service ensures the user has a valid license key:

```
const VALID_KEYS = [
  'KONTR-NAHRYUK-2024',
  'KONTR-NAHRYUK-2024-PREMIUM',
  'KONTR-NAHRYUK-PRO',
  'KONTR-NAHRYUK-ENTERPRISE'
]

if (!this.licenseKey || !VALID_KEYS.includes(this.licenseKey.trim().toUpperCase())) {
  return {
    hasAccess: false,
    reason: 'Потрібен дійсний ліцензійний ключ'
  }
}
```

Summary
-------
* `UpdateService` fetches the latest GitHub release, compares versions, and downloads portable assets.
* `ipcMain` handlers expose `get-version`, `check-github`, and `download-and-install` endpoints.
* `UpdateManager` in the renderer updates the UI, displays status, and triggers downloads.
* Licensing gates access to updates until a valid key is provided.
